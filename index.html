<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video YouTube v·ªõi Ph·ª• ƒë·ªÅ, TTS v√† T·ª´ v·ª±ng (Ho√†n h·∫£o)</title>
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            text-align: center;
            transition: all 0.3s ease;
        }
        .container {
            margin-top: 20px;
        }
        input, button {
            margin: 5px;
            padding: 8px;
            width: 100%;
            box-sizing: border-box;
        }
        #video-container {
            margin-top: 20px;
            position: relative;
            padding-bottom: 56.25%; /* 16:9 ratio */
            height: 0;
            overflow: hidden;
        }
        #video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #subtitle-display {
            font-size: 18px;
            margin-top: 10px;
            color: #333;
            border: 1px solid #ccc;
            padding: 10px;
            text-align: left;
        }
        #subtitle-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            margin-top: 20px;
            text-align: left;
            padding: 10px;
        }
        .subtitle-item {
            padding: 5px;
            cursor: pointer;
        }
        .subtitle-item:hover {
            background-color: #f0f0f0;
        }
        .subtitle-item.active {
            background-color: #d0e8ff;
        }
        #tts-speed-container, #tts-language-container {
            margin-top: 10px;
        }
        .korean-word {
            color: #0066cc;
            cursor: pointer;
        }
        .korean-word:hover {
            text-decoration: underline;
        }
        .vietnamese {
            color: #cc0000;
        }
        .subtitle-line {
            padding: 5px 0;
        }
        .subtitle-line.current {
            background-color: #d0e8ff;
            font-weight: bold;
        }
        #history-list, #vocab-list, #favorite-subtitles {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ccc;
            margin-top: 20px;
            text-align: left;
            padding: 10px;
        }
        .history-item, .vocab-item {
            padding: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .history-item:hover, .vocab-item:hover {
            background-color: #f0f0f0;
        }
        .history-item button, .vocab-item button {
            margin-left: 10px;
            padding: 2px 5px;
            background-color: #ff4d4d;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .history-item button:hover, .vocab-item button:hover {
            background-color: #cc0000;
        }
        .volume-container {
            margin: 10px 0;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #subtitle-link {
            margin-top: 10px;
            color: #0066cc;
            text-decoration: none;
        }
        #subtitle-link:hover {
            text-decoration: underline;
        }
        .control-buttons {
            margin: 10px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .rewind-btn {
            background-color: #4CAF50;
            color: white;
        }
        .rewind-btn:hover {
            background-color: #45a049;
        }
        .test-tts-btn {
            background-color: #ff9800;
            color: white;
        }
        .test-tts-btn:hover {
            background-color: #e68a00;
        }
        .auto-sub-btn {
            background-color: #2196F3;
            color: white;
        }
        .auto-sub-btn:hover {
            background-color: #1976D2;
        }
        .repeat-btn {
            background-color: #9c27b0;
            color: white;
        }
        .repeat-btn:hover {
            background-color: #7b1fa2;
        }
        .translate-srt-btn {
            background-color: #f44336;
            color: white;
        }
        .translate-srt-btn:hover {
            background-color: #d32f2f;
        }
        #translation-progress {
            margin-top: 10px;
        }
        #progress-text {
            margin-left: 10px;
        }
        @media (max-width: 600px) {
            body {
                margin: 10px;
            }
            input, button {
                padding: 6px;
                font-size: 14px;
            }
            #subtitle-display {
                font-size: 16px;
            }
            .control-buttons {
                flex-direction: column;
            }
        }
        .korean-word.clickable {
            color: #0066cc;
            cursor: pointer;
            padding: 5px;
            display: inline-block;
        }
        .korean-word.clickable:hover {
            text-decoration: underline;
            background-color: #f0f0f0;
        }
        .vietnamese.translation {
            color: #cc0000;
            margin-left: 10px;
        }
        .vocab-item-naver {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .inline-meaning {
            font-size: 12px;
            color: #888;
            margin-left: 4px;
        }
        .korean-word.learned {
            background-color: #fff3cd;
            border-bottom: 1px dotted #ffa500;
            padding: 2px 4px;
            border-radius: 3px;
            cursor: pointer;
        }
        .clickable-vocab {
            padding: 5px;
            border-bottom: 1px solid #ddd;
        }
        .clickable-vocab:hover {
            background-color: #f0f0f0;
            cursor: pointer;
        }
        /* Ki·ªÉu m·ªõi cho ph·∫ßn hi·ªÉn th·ªã t·ª´ v·ª±ng */
        .vocab-info-item {
            padding: 12px;
            margin: 8px 0;
            background-color: #fff;
            border-left: 4px solid #4CAF50;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .vocab-info-korean {
            font-weight: bold;
            color: #2196F3;
            font-size: 1.2em;
        }
        .vocab-info-meaning {
            color: #FF5722;
            margin-left: 8px;
            font-size: 1em;
        }
        .vocab-info-time {
            color: #607D8B;
            font-size: 0.85em;
            margin-left: 5px;
        }
        .vocab-info-notebook {
            color: #9C27B0;
            font-style: italic;
            margin-top: 5px;
        }
        #vocab-info-display button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            margin-left: 8px;
            cursor: pointer;
            font-size: 0.8em;
        }
        #vocab-info-display button:hover {
            background-color: #388E3C;
        }
    </style>
</head>
<body>
    <h1>Video YouTube v·ªõi Ph·ª• ƒë·ªÅ, TTS v√† T·ª´ v·ª±ng (Ho√†n h·∫£o)</h1>
    <div class="container">
        <input type="text" id="video-url" placeholder="Nh·∫≠p link YouTube (v√≠ d·ª•: https://www.youtube.com/watch?v=dQw4w9WgXcQ)">
        <button onclick="loadVideo()">T·∫£i Video</button>
        <div id="subtitle-link-container" style="display:none;">
            <a id="subtitle-link" target="_blank">T·∫£i ph·ª• ƒë·ªÅ t·ª´ subtitle.to</a>
        </div>
        <br>
        <input type="file" id="subtitle-file" accept=".srt">
        <button onclick="loadSubtitles()">T·∫£i Ph·ª• ƒë·ªÅ</button>
        <button class="auto-sub-btn" onclick="loadAutoSubtitles()">T·∫£i Ph·ª• ƒë·ªÅ T·ª± ƒë·ªông</button>
        <br>
        <div class="control-buttons">
            <button onclick="startReading()">B·∫Øt ƒë·∫ßu ƒê·ªçc</button>
            <button onclick="stopReading()">D·ª´ng TTS</button>
            <button class="rewind-btn" onclick="rewindSubtitle()">L√πi 5 gi√¢y</button>
            <button class="test-tts-btn" onclick="testTTS()">Ki·ªÉm tra TTS</button>
            <button class="repeat-btn" onclick="toggleRepeat()">L·∫∑p Ph·ª• ƒë·ªÅ (B·∫≠t/T·∫Øt)</button>
            <button onclick="saveState()">L∆∞u Tr·∫°ng Th√°i</button>
            <button class="translate-srt-btn" onclick="translateSRT()">D·ªãch Ph·ª• ƒë·ªÅ</button>
        </div>
        <input type="file" id="state-file" accept=".json">
        <button onclick="loadState()">T·∫£i Tr·∫°ng Th√°i</button>
        <div id="tts-speed-container">
            <label for="tts-speed">T·ªëc ƒë·ªô TTS: </label>
            <input type="range" id="tts-speed" min="0.5" max="2.5" step="0.1" value="1.5" onchange="updateTTSSpeed(this.value)">
            <span id="speed-value">1.5</span>
        </div>
        <div id="tts-language-container">
            <label for="tts-language">Ng√¥n ng·ªØ TTS: </label>
            <select id="tts-language" onchange="updateTTSLanguage(this.value)">
                <option value="vi-VN">Ti·∫øng Vi·ªát</option>
                <option value="ko-KR">Ti·∫øng H√†n</option>
            </select>
        </div>
        <div style="margin-top:10px; display: flex; align-items: center; justify-content: center; gap: 5px;">
            <label for="subtitle-offset">L·ªách th·ªùi gian ph·ª• ƒë·ªÅ (gi√¢y): </label>
            <button onclick="toggleNegativeOffset()">-</button>
            <input type="number" id="subtitle-offset" min="-5" max="5" step="0.1" value="0" style="width: 70px; text-align: center;" onchange="updateSubtitleOffset(this.value)">
            <span id="offset-value">0.0</span>
            <button onclick="applyOffsetToSubtitles()">√Åp d·ª•ng l·ªách vƒ©nh vi·ªÖn</button>
        </div>
        <div class="volume-container">
            <div class="volume-control">
                <label for="video-volume">√Çm l∆∞·ª£ng Video: </label>
                <input type="range" id="video-volume" min="0" max="100" value="100" onchange="updateVideoVolume(this.value)">
                <span id="video-volume-value">100</span>
            </div>
            <div class="volume-control">
                <label for="tts-volume">√Çm l∆∞·ª£ng TTS: </label>
                <input type="range" id="tts-volume" min="0" max="1" step="0.1" value="1" onchange="updateTTSVolume(this.value)">
                <span id="tts-volume-value">1.0</span>
            </div>
        </div>
        <div style="margin-top: 20px; border: 1px solid #ccc; padding: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h3>Th√¥ng tin t·ª´ v·ª±ng ƒë√£ ch·ªçn</h3>
                <div>
                    <label style="cursor: pointer;">
                        <input type="checkbox" id="vocab-display-mode" onchange="toggleVocabDisplayMode()" style="margin-right: 5px;">
                        Ch·ªâ hi·ªÉn th·ªã th√¥ng tin (kh√¥ng tra Naver)
                    </label>
                    <button onclick="clearVocabDisplay()" style="margin-left: 10px; padding: 3px 8px; background-color: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer;">X√≥a</button>
                </div>
            </div>
            <div id="vocab-info-display" style="margin-top: 10px; min-height: 80px; border: 1px dashed #ccc; padding: 10px; background-color: #f8f9fa;">
                üëâ Nh·∫•p v√†o t·ª´ v·ª±ng ƒë∆∞·ª£c t√¥ m√†u trong ph·ª• ƒë·ªÅ ƒë·ªÉ xem chi ti·∫øt
            </div>
        </div>
        <div id="translation-progress" style="display: none;">
            <progress id="progress-bar" value="0" max="100"></progress>
            <span id="progress-text">ƒêang d·ªãch... 0%</span>
        </div>
    </div>
    <div id="video-container">
        <iframe id="youtube-video" frameborder="0" allowfullscreen></iframe>
    </div>
    <div id="subtitle-display"></div>
    <div id="subtitle-list"></div>
    <h3>L·ªãch s·ª≠ xem</h3>
    <div id="history-list"></div>
    <div style="margin-top: 20px;">
        <label>
            <input type="checkbox" id="instant-lookup-toggle" checked onchange="toggleInstantLookup(this.checked)">
            B·∫≠t tra t·ª´ ngay khi nh·∫•n
        </label>
        <button onclick="translateAllVocab()">D·ªãch t·∫•t c·∫£ t·ª´ v·ª±ng b·∫±ng Google D·ªãch</button>
    </div>
    <h3>Danh s√°ch t·ª´ v·ª±ng ƒë√£ tra</h3>
    <h3>Danh s√°ch t·ª´ NotebookLM</h3>
    <textarea id="notebooklm-vocab" rows="10" placeholder="D√°n danh s√°ch t·ª´ ·ªü ƒë√¢y..."></textarea>
    
                    <div style="margin-top: 10px; display: flex; align-items: center; gap: 5px;">
                        <input type="text" id="chars-to-remove" placeholder="Nh·∫≠p k√Ω t·ª± c·∫ßn x√≥a (v√≠ d·ª•: *>)">
                        <button onclick="removeCharacters()">X√≥a k√Ω t·ª±</button>
                    </div>
                    <button onclick="linkVocabToSubtitles()">Li√™n k·∫øt t·ª´ v·ª±ng v·ªõi ph·ª• ƒë·ªÅ</button>
                    <script>
                        function removeCharacters() {
                            const textArea = document.getElementById("notebooklm-vocab");
                            const charsToRemove = document.getElementById("chars-to-remove").value;
                            if (textArea && charsToRemove) {
                                let content = textArea.value;
                                for (let i = 0; i < charsToRemove.length; i++) {
                                    const char = charsToRemove[i];
                                    content = content.split(char).join("");
                                }
                                textArea.value = content;
                            }
                        }
                    </script>
                
    <div id="linked-vocab-list"></div>
    <div style="margin-top: 10px;">
        <button id="vocab-tts-toggle" onclick="toggleVocabTTSMode()">Ch·∫ø ƒë·ªô ƒë·ªçc t·ª´ v·ª±ng (T·∫Øt)</button>
        <button id="start-vocab-tts" onclick="startVocabTTS()" disabled>B·∫Øt ƒë·∫ßu ƒë·ªçc t·ª´ v·ª±ng</button>
        <button id="pause-vocab-tts" onclick="pauseVocabTTS()" disabled>T·∫°m d·ª´ng</button>
        <button id="stop-vocab-tts" onclick="stopVocabTTS()" disabled>D·ª´ng h·∫≥n</button>
    </div>
    <div style="margin-bottom: 10px;">
        <label>
            <input type="checkbox" id="naver-lookup-toggle" onchange="toggleNaverLookup(this.checked)">
            B·∫≠t tra t·ª´ tr√™n Naver
        </label>
    </div>
    <div id="vocab-list"></div>
    <h3>Ph·ª• ƒë·ªÅ y√™u th√≠ch</h3>
    <button onclick="clearAllFavorites()">X√≥a t·∫•t c·∫£ ph·ª• ƒë·ªÅ y√™u th√≠ch</button>
    <div id="favorite-subtitles"></div>

    <script>
        let youtubePlayer;
        let subtitleData = [];
        let currentSubtitleIndex = -1;
        let isSpeaking = false;
        let ttsSpeed = 1.5;
        let ttsLanguage = "vi-VN";
        let history = [];
        let currentVideoUrl = "";
        let vocabList = [];
        let instantLookupEnabled = true;
        let naverLookupEnabled = false;
        let ttsVolume = 1.0;
        let syncInterval;
        let lastSpokenText = "";
        let lastSpokenTime = 0;
        let lastCheckedTime = 0;
        let isManualSeeking = false;
        let isRepeating = false;
        let repeatCount = 0;
        const maxRepeatCount = 3;
        let subtitleOffset = 0;
        let currentVideoFavorites = [];
        let vocabTTSMode = false;
        let vocabTTSIndex = -1;
        let vocabTTSTimeout;
        let isVocabTTSPaused = false;
        let pausedVocabIndex = -1;
        let vocabDisplayMode = false;

        function findBestSubtitleIndex(vocabWord) {
            const cleanVocab = vocabWord.replace(/[^\p{Script=Hangul}]+/gu, "").trim().substring(0, 2);
            if (cleanVocab.length < 2) return -1;
            
            for (let i = 0; i < subtitleData.length; i++) {
                const subtitleText = subtitleData[i].koreanText;
                const wordsInSubtitle = subtitleText.split(/\s+/);
                for (let word of wordsInSubtitle) {
                    const cleanWord = word.replace(/[^\p{Script=Hangul}]+/gu, "").trim();
                    if (cleanWord.length >= 2 && cleanWord.substring(0, 2) === cleanVocab) {
                        return i;
                    }
                }
            }
            return -1;
        }

        function linkVocabToSubtitles() {
            const vocabText = document.getElementById("notebooklm-vocab").value;
            const vocabArray = vocabText
                .split("\n")
                .map(v => {
                    const match = v.match(/[\p{Script=Hangul}]+(?:\s+[\p{Script=Hangul}]+)*/gu);
                    const korean = match ? match[0].trim() : "";
                    const meaningMatch = v.split(":").slice(1).join(":").trim();
                    const meaning = meaningMatch ? meaningMatch : "";
                    return korean ? { korean, meaning } : null;
                })
                .filter(v => v);
            const container = document.getElementById("linked-vocab-list");
            container.innerHTML = "";

            vocabArray.forEach(word => {
                const div = document.createElement("div");
                div.textContent = `${word.korean} ${word.meaning ? `- ${word.meaning}` : ""}`;
                div.className = "clickable-vocab";

                div.onclick = () => {
                    const matchIndex = findBestSubtitleIndex(word.korean);
                    if (matchIndex !== -1) {
                        youtubePlayer.seekTo(subtitleData[matchIndex].startTime, true);
                        youtubePlayer.playVideo();
                        highlightSubtitle(matchIndex);
                        if (vocabTTSMode) {
                            readTextDual(`${word.korean} - ${word.meaning}`);
                        }
                    } else {
                        alert("Kh√¥ng t√¨m th·∫•y t·ª´ g·∫ßn gi·ªëng trong ph·ª• ƒë·ªÅ");
                    }
                };
                container.appendChild(div);
            });
            saveToHistory(currentVideoUrl, null, vocabText);
        }

        function checkManualSeek() {
            if (!youtubePlayer) return;
            const currentTime = youtubePlayer.getCurrentTime();
            const timeDiff = Math.abs(currentTime - lastCheckedTime);
            if (timeDiff > 1 && timeDiff < 10) {
                isManualSeeking = true;
                handleManualSeek(currentTime);
            }
            lastCheckedTime = currentTime;
        }

        function handleManualSeek(currentTime) {
            if (!subtitleData.length) return;
            let newIndex = -1;
            for (let i = 0; i < subtitleData.length; i++) {
                if (subtitleData[i].startTime <= currentTime) {
                    newIndex = i;
                } else {
                    break;
                }
            }
            if (newIndex >= 0 && newIndex !== currentSubtitleIndex) {
                currentSubtitleIndex = newIndex;
                updateSubtitleDisplay(newIndex);
                if (isSpeaking) {
                    const textToRead = ttsLanguage === "vi-VN" ? subtitleData[newIndex].vietnameseText : subtitleData[newIndex].koreanText;
                    speechSynthesis.cancel();
                    readText(textToRead, () => { isSpeaking = false; });
                }
            }
            isManualSeeking = false;
        }

        function waitForPlayer() {
            return new Promise((resolve, reject) => {
                const startTime = Date.now();
                const checkPlayer = () => {
                    if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.setVolume) {
                        resolve();
                    } else if (Date.now() - startTime > 10000) {
                        reject(new Error("YouTube player failed to initialize"));
                    } else {
                        setTimeout(checkPlayer, 100);
                    }
                };
                checkPlayer();
            });
        }

        function waitForVoices() {
            return new Promise((resolve) => {
                if (speechSynthesis.getVoices().length > 0) {
                    resolve();
                } else {
                    speechSynthesis.onvoiceschanged = () => {
                        speechSynthesis.onvoiceschanged = null;
                        resolve();
                    };
                }
            });
        }

        function loadVideo() {
            const urlInput = document.getElementById("video-url").value;
            const videoId = extractVideoId(urlInput);
            if (!videoId) {
                alert("URL kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p link d·∫°ng https://www.youtube.com/watch?v=dQw4w9WgXcQ");
                return;
            }
            currentVideoUrl = urlInput;
            const iframe = document.getElementById("youtube-video");
            iframe.src = `https://www.youtube.com/embed/${videoId}?enablejsapi=1`;
            const subtitleLinkContainer = document.getElementById("subtitle-link-container");
            const subtitleLink = document.getElementById("subtitle-link");
            subtitleLink.href = `https://subtitle.to/${urlInput}`;
            subtitleLink.textContent = `T·∫£i ph·ª• ƒë·ªÅ t·ª´ subtitle.to cho video n√†y`;
            subtitleLinkContainer.style.display = "block";
            initializePlayer();
            const historyItem = history.find(item => item.videoUrl === urlInput);
            vocabList = historyItem && historyItem.vocabList ? historyItem.vocabList.slice() : [];
            currentVideoFavorites = historyItem && historyItem.favoriteSubtitles ? historyItem.favoriteSubtitles.slice() : [];
            document.getElementById("notebooklm-vocab").value = historyItem && historyItem.notebooklmVocab ? historyItem.notebooklmVocab : "";
            saveToHistory(urlInput, null, document.getElementById("notebooklm-vocab").value);
            displayVocabList();
            displayFavorites();
            instantLookupEnabled = localStorage.getItem("instantLookup") === "1";
            document.getElementById("instant-lookup-toggle").checked = instantLookupEnabled;
        }

        async function loadAutoSubtitles() {
            alert("ƒêang th·ª≠ t·∫£i ph·ª• ƒë·ªÅ t·ª± ƒë·ªông t·ª´ subtitle.to...");
            try {
                const response = await new Promise(resolve => {
                    setTimeout(() => resolve({ text: `1\n00:00:01,000 --> 00:00:03,000\nÏïàÎÖïÌïòÏÑ∏Ïöî\nXin ch√†o\n\n2\n00:00:03,001 --> 00:00:05,000\nÎßåÎÇòÏÑú Î∞òÍ∞ëÏäµÎãàÎã§\nR·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n` }), 1000);
                });
                subtitleData = parseSRT(response.text);
                if (subtitleData.length === 0) {
                    alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c ph·ª• ƒë·ªÅ!");
                    return;
                }
                alert(`ƒê√£ t·∫£i ${subtitleData.length} d√≤ng ph·ª• ƒë·ªÅ t·ª± ƒë·ªông!`);
                displaySubtitleList();
                saveToHistory(currentVideoUrl, response.text, document.getElementById("notebooklm-vocab").value);
            } catch (error) {
                console.error("L·ªói t·∫£i ph·ª• ƒë·ªÅ t·ª± ƒë·ªông:", error);
                alert("L·ªói khi t·∫£i ph·ª• ƒë·ªÅ t·ª± ƒë·ªông: " + error.message);
            }
        }

        function extractVideoId(url) {
            const match = url.match(/(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=))([^?&]+)/);
            return match ? match[1] : null;
        }

        function initializePlayer() {
            youtubePlayer = new YT.Player("youtube-video", {
                events: {
                    onReady: () => {
                        setInterval(checkManualSeek, 1000);
                        console.log("Video ƒë√£ s·∫µn s√†ng");
                        updateVideoVolume(document.getElementById("video-volume").value);
                    },
                    onStateChange: (event) => {
                        if (event.data === YT.PlayerState.PLAYING) {
                            startReading();
                        } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                            stopReading();
                        }
                    }
                }
            });
        }

        function updateVideoVolume(value) {
            if (youtubePlayer && youtubePlayer.setVolume) {
                youtubePlayer.setVolume(parseInt(value));
                document.getElementById("video-volume-value").textContent = value;
            }
        }

        function updateTTSVolume(value) {
            ttsVolume = parseFloat(value);
            document.getElementById("tts-volume-value").textContent = ttsVolume.toFixed(1);
            localStorage.setItem("ttsVolume", ttsVolume);
        }

        function updateTTSLanguage(language) {
            ttsLanguage = language;
            localStorage.setItem("ttsLanguage", ttsLanguage);
        }

        function updateSubtitleOffset(value) {
            const newOffset = parseFloat(value) || 0;
            if (Math.abs(newOffset - subtitleOffset) > 0.05) {
                subtitleOffset = newOffset;
                document.getElementById("offset-value").textContent = subtitleOffset.toFixed(1);
                localStorage.setItem("subtitleOffset", subtitleOffset);
                if (syncInterval) {
                    clearInterval(syncInterval);
                    syncInterval = setInterval(syncSubtitles, 300);
                    syncSubtitles();
                }
            }
        }

        function toggleNegativeOffset() {
            const input = document.getElementById("subtitle-offset");
            let value = parseFloat(input.value);
            if (value > 0) {
                value = -value;
            } else if (value < 0) {
                value = Math.abs(value);
            } else {
                value = -0.1;
            }
            input.value = value.toFixed(1);
            updateSubtitleOffset(input.value);
        }

        function applyOffsetToSubtitles() {
            const offset = parseFloat(document.getElementById("subtitle-offset").value) || 0;
            if (!subtitleData.length) {
                alert("Ch∆∞a c√≥ ph·ª• ƒë·ªÅ ƒë·ªÉ ch·ªânh th·ªùi gian.");
                return;
            }

            subtitleData.forEach(sub => {
                sub.startTime = Math.max(0, sub.startTime + offset);
                sub.endTime = Math.max(0, sub.endTime + offset);
            });
            subtitleOffset = 0;
            document.getElementById("subtitle-offset").value = "0";
            document.getElementById("offset-value").textContent = "0.0";
            localStorage.setItem("subtitleOffset", "0");

            displaySubtitleList();
            alert(`ƒê√£ √°p d·ª•ng l·ªách ${offset} gi√¢y vƒ©nh vi·ªÖn cho to√†n b·ªô ph·ª• ƒë·ªÅ.`);
        }

        function loadSubtitles() {
            const fileInput = document.getElementById("subtitle-file").files[0];
            if (!fileInput) {
                alert("Vui l√≤ng ch·ªçn file SRT!");
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                subtitleData = parseSRT(event.target.result);
                if (subtitleData.length === 0) {
                    alert("File SRT kh√¥ng h·ª£p l·ªá ho·∫∑c tr·ªëng!");
                    return;
                }
                alert(`ƒê√£ t·∫£i ${subtitleData.length} d√≤ng ph·ª• ƒë·ªÅ!`);
                displaySubtitleList();
                saveToHistory(currentVideoUrl, event.target.result, document.getElementById("notebooklm-vocab").value);
            };
            reader.readAsText(fileInput);
        }

        function parseSRT(srtContent) {
            const subtitleBlocks = srtContent.trim().split(/\n\s*\n/);
            return subtitleBlocks.map(block => {
                const lines = block.split("\n");
                if (lines.length < 3) return null;

                const timing = lines[1].split(" --> ");
                const startTimeParts = timing[0].split(/[:,]/);
                const endTimeParts = timing[1].split(/[:,]/);
                const startTime = parseInt(startTimeParts[0]) * 3600 + parseInt(startTimeParts[1]) * 60 + parseFloat(`${startTimeParts[2]}.${startTimeParts[3] || '0'}`);
                const endTime = parseInt(endTimeParts[0]) * 3600 + parseInt(endTimeParts[1]) * 60 + parseFloat(`${endTimeParts[2]}.${endTimeParts[3] || '0'}`);

                if (lines.length === 3) {
                    const koreanText = lines[2].trim();
                    return { 
                        startTime: isNaN(startTime) ? 0 : startTime,
                        endTime: isNaN(endTime) ? startTime + 2 : endTime,
                        fullText: koreanText, 
                        koreanText, 
                        vietnameseText: ""
                    };
                } else {
                    const koreanText = lines[2].trim();
                    const vietnameseText = lines[3].trim();
                    return { 
                        startTime: isNaN(startTime) ? 0 : startTime,
                        endTime: isNaN(endTime) ? startTime + 2 : endTime,
                        fullText: `${koreanText} ${vietnameseText}`, 
                        koreanText, 
                        vietnameseText 
                    };
                }
            }).filter(item => item && typeof item.startTime === 'number' && item.koreanText);
        }

        async function translateSRT() {
            if (!subtitleData.length) {
                alert("Vui l√≤ng t·∫£i ph·ª• ƒë·ªÅ tr∆∞·ªõc!");
                return;
            }
            
            const hasVietnamese = subtitleData.some(sub => sub.vietnameseText && sub.vietnameseText.trim() !== "");
            if (hasVietnamese) {
                alert("Ph·ª• ƒë·ªÅ ƒë√£ c√≥ b·∫£n d·ªãch ti·∫øng Vi·ªát!");
                return;
            }
            
            if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën d·ªãch ${subtitleData.length} d√≤ng ph·ª• ƒë·ªÅ sang ti·∫øng Vi·ªát? Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t kho·∫£ng ${Math.ceil(subtitleData.length * 0.5 / 60)} ph√∫t.`)) {
                return;
            }
            
            try {
                const wasPlaying = youtubePlayer && youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING;
                if (wasPlaying) {
                    youtubePlayer.pauseVideo();
                }
                
                document.getElementById("translation-progress").style.display = "block";
                for (let i = 0; i < subtitleData.length; i++) {
                    const sub = subtitleData[i];
                    const progress = Math.floor((i / subtitleData.length) * 100);
                    document.getElementById("progress-bar").value = progress;
                    document.getElementById("progress-text").textContent = `ƒêang d·ªãch... ${progress}%`;
                    
                    sub.vietnameseText = await translateText(sub.koreanText);
                    sub.fullText = `${sub.koreanText} ${sub.vietnameseText}`;
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                document.getElementById("translation-progress").style.display = "none";
                alert(`ƒê√£ d·ªãch xong ${subtitleData.length} d√≤ng ph·ª• ƒë·ªÅ!`);
                displaySubtitleList();
                saveToHistory(currentVideoUrl, convertToSRT(subtitleData), document.getElementById("notebooklm-vocab").value);
                if (wasPlaying) {
                    youtubePlayer.playVideo();
                }
            } catch (error) {
                console.error("L·ªói khi d·ªãch ph·ª• ƒë·ªÅ:", error);
                document.getElementById("translation-progress").style.display = "none";
                alert("L·ªói khi d·ªãch ph·ª• ƒë·ªÅ: " + error.message);
            }
        }

        async function translateText(text) {
            try {
                const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=vi&dt=t&q=${encodeURIComponent(text)}`;
                const res = await fetch(url);
                const data = await res.json();
                return data[0].map(x => x[0]).join('');
            } catch (e) {
                console.error("L·ªói d·ªãch Google:", e);
                return "[L·ªói d·ªãch]";
            }
        }

        function convertToSRT(subtitles) {
            let srtContent = "";
            subtitles.forEach((sub, index) => {
                const startTime = formatTimeForSRT(sub.startTime);
                const endTime = formatTimeForSRT(sub.endTime || sub.startTime + 2);
                
                srtContent += `${index + 1}\n`;
                srtContent += `${startTime} --> ${endTime}\n`;
                srtContent += `${sub.koreanText}\n`;
                srtContent += `${sub.vietnameseText || ''}\n\n`;
            });
            return srtContent;
        }

        function formatTimeForSRT(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
        }

        function displaySubtitleList() {
            const subtitleList = document.getElementById("subtitle-list");
            subtitleList.innerHTML = "";
            subtitleData.forEach((sub, index) => {
                const div = document.createElement("div");
                div.className = "subtitle-item";
                div.innerHTML = `${formatTime(sub.startTime)}: <span class="korean">${sub.koreanText}</span> <span class="vietnamese">${sub.vietnameseText}</span> <button onclick="addFavoriteToCurrentVideo(${index}); event.stopPropagation();">Y√™u th√≠ch</button>`;
                div.onclick = () => jumpToSubtitle(index);
                subtitleList.appendChild(div);
            });
        }

        async function fetchGoogleTranslate(text) {
            try {
                const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=ko&tl=vi&dt=t&q=${encodeURIComponent(text)}`;
                const res = await fetch(url);
                const data = await res.json();
                const translated = data[0].map(x => x[0]).join('');
                const index = vocabList.findIndex(item => item.word === text);
                if (index !== -1) {
                    vocabList[index].meaning = translated;
                    saveVocabToHistory();
                    displayVocabList();
                    updateSubtitleDisplay(currentSubtitleIndex);
                } else {
                    vocabList.push({ word: text, meaning: translated });
                    saveVocabToHistory();
                    displayVocabList();
                }
            } catch (e) {
                console.error("L·ªói d·ªãch Google:", e);
            }
        }

        async function translateAllVocab() {
            for (let item of vocabList) {
                if (!item.meaning || item.meaning === "ƒêang tra c·ª©u...") {
                    await fetchGoogleTranslate(item.word);
                    await new Promise(r => setTimeout(r, 200));
                }
            }
            alert("ƒê√£ d·ªãch xong t·∫•t c·∫£ t·ª´ v·ª±ng!");
        }

        function toggleInstantLookup(enabled) {
            instantLookupEnabled = enabled;
            localStorage.setItem("instantLookup", enabled ? "1" : "0");
        }

        /* ===== PH·∫¶N M·ªöI CHO HI·ªÇN TH·ªä T·ª™ V·ª∞NG ===== */
        function toggleVocabDisplayMode() {
            vocabDisplayMode = !vocabDisplayMode;
            document.getElementById("vocab-display-mode").checked = vocabDisplayMode;
            localStorage.setItem("vocabDisplayMode", vocabDisplayMode);
            alert(`Ch·∫ø ƒë·ªô hi·ªÉn th·ªã: ${vocabDisplayMode ? "CH·ªà hi·ªÉn th·ªã th√¥ng tin" : "TRA T·ª™ tr√™n Naver khi nh·∫•p"}`);
        }

        function clearVocabDisplay() {
            document.getElementById("vocab-info-display").innerHTML = "üëâ Nh·∫•p v√†o t·ª´ v·ª±ng ƒë∆∞·ª£c t√¥ m√†u trong ph·ª• ƒë·ªÅ ƒë·ªÉ xem chi ti·∫øt";
        }

        function handleWordClick(word) {
            // Lu√¥n th√™m t·ª´ v√†o danh s√°ch n·∫øu ch∆∞a c√≥
            const existing = vocabList.find(item => item.word === word);
            if (!existing) {
                vocabList.push({ word, meaning: "ƒêang tra c·ª©u..." });
                saveVocabToHistory();
                displayVocabList();
            }
            
            // Sau ƒë√≥ g·ªçi lookupWord nh∆∞ b√¨nh th∆∞·ªùng
            lookupWord(word);
        }

        function lookupWord(word) {
            // Lu√¥n th√™m t·ª´ v√†o danh s√°ch t·ª´ v·ª±ng n·∫øu ch∆∞a c√≥
            const existingVocab = vocabList.find(item => item.word === word);
            if (!existingVocab) {
                vocabList.push({ word, meaning: "ƒêang tra c·ª©u..." });
                saveVocabToHistory();
                displayVocabList();
            }

            // T√¨m trong NotebookLM
            const notebookVocab = getNotebookVocabInfo(word);
            
            if (vocabDisplayMode) {
                displayVocabInfo(word, existingVocab || vocabList.find(item => item.word === word), notebookVocab);
            } else if (instantLookupEnabled) {
                openNaverDict(word);
                if (!existingVocab) {
                    fetchGoogleTranslate(word);
                }
            } else {
                // Khi c·∫£ hai ch·∫ø ƒë·ªô ƒë·ªÅu t·∫Øt, v·∫´n hi·ªÉn th·ªã th√¥ng tin c∆° b·∫£n
                displayVocabInfo(word, existingVocab || vocabList.find(item => item.word === word), notebookVocab);
            }
        }

        function getNotebookVocabInfo(word) {
            const notebookText = document.getElementById("notebooklm-vocab").value;
            if (!notebookText.trim()) return null;
            
            const lines = notebookText.split('\n');
            for (const line of lines) {
                if (line.includes(word)) {
                    const [korean, ...meaningParts] = line.split(':');
                    return {
                        korean: korean.trim(),
                        meaning: meaningParts.join(':').trim()
                    };
                }
            }
            return null;
        }

        function displayVocabInfo(word, existingVocab, notebookVocab) {
            const container = document.getElementById("vocab-info-display");
            let html = `<div class="vocab-info-item">`;
            
            html += `<div><span class="vocab-info-korean">${word}</span>`;
            
            if (existingVocab?.meaning) {
                html += `<span class="vocab-info-meaning">${existingVocab.meaning}</span>`;
            }
            html += `</div>`;
            
            if (notebookVocab?.meaning && (!existingVocab || notebookVocab.meaning !== existingVocab.meaning)) {
                html += `<div class="vocab-info-notebook">üìî NotebookLM: ${notebookVocab.meaning}</div>`;
            }
            
            const appearances = findWordAppearances(word);
            if (appearances.length > 0) {
                html += `<div style="margin-top:10px;font-size:0.9em;color:#555;">`;
                html += `<div>üïí Xu·∫•t hi·ªán trong video:</div>`;
                appearances.forEach((time, idx) => {
                    html += `<div style="margin-top:4px;">
                        <span class="vocab-info-time">${formatTime(time.startTime)}</span>
                        <button onclick="jumpToSubtitle(${time.subtitleIndex})">Xem</button>
                    </div>`;
                });
                html += `</div>`;
            }
            
            html += `</div>`;
            container.innerHTML = html;
        }

        function findWordAppearances(word) {
            const result = [];
            const cleanWord = word.replace(/[^\p{Script=Hangul}]+/gu, "").trim();
            if (!cleanWord || !subtitleData.length) return result;
            
            subtitleData.forEach((sub, idx) => {
                if (sub.koreanText.includes(cleanWord)) {
                    result.push({
                        startTime: sub.startTime,
                        subtitleIndex: idx
                    });
                }
            });
            
            return result;
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600).toString().padStart(2, "0");
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, "0");
            const s = Math.floor(seconds % 60).toString().padStart(2, "0");
            return `${h}:${m}:${s}`;
        }

        function jumpToSubtitle(index) {
            if (!youtubePlayer) {
                alert("Vui l√≤ng t·∫£i video tr∆∞·ªõc!");
                return;
            }
            currentSubtitleIndex = index - 1;
            youtubePlayer.seekTo(subtitleData[index].startTime, true);
            youtubePlayer.playVideo();
            
            highlightSubtitle(index);

            // === AUTO SCROLL ACTIVE SUBTITLE ===
            setTimeout(() => {
                const activeItem = document.querySelector('.subtitle-item.active');
                if (activeItem) {
                    activeItem.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }, 50);
        }


        function highlightSubtitle(index) {
            const items = document.getElementsByClassName("subtitle-item");
            for (let i = 0; i < items.length; i++) {
                items[i].classList.remove("active");
            }
            if (items[index]) items[index].classList.add("active");
        }

        function updateTTSSpeed(value) {
            ttsSpeed = parseFloat(value);
            document.getElementById("speed-value").textContent = ttsSpeed;
            localStorage.setItem("ttsSpeed", ttsSpeed);
        }

        function startReading() {
            if (!youtubePlayer || subtitleData.length === 0) {
                alert("Vui l√≤ng t·∫£i video v√† ph·ª• ƒë·ªÅ tr∆∞·ªõc!");
                return;
            }
            if (syncInterval) {
                clearInterval(syncInterval);
            }
            syncInterval = setInterval(() => {
                syncSubtitles();
            }, 200);
            syncSubtitles();
        }

        function syncSubtitles() {
            if (!youtubePlayer || youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                return;
            }
            const currentTime = youtubePlayer.getCurrentTime() + subtitleOffset;
            let nextSubtitle = null;
            let nextIndex = -1;
            for (let i = 0; i < subtitleData.length; i++) {
                if (subtitleData[i].startTime <= currentTime) {
                    nextSubtitle = subtitleData[i];
                    nextIndex = i;
                } else {
                    break;
                }
            }
            if (nextSubtitle && nextIndex !== currentSubtitleIndex) {
                currentSubtitleIndex = nextIndex;
                updateSubtitleDisplay(currentSubtitleIndex);
                const textToRead = ttsLanguage === "vi-VN" ? nextSubtitle.vietnameseText : nextSubtitle.koreanText;
                const currentTimeMs = Date.now();
                if (textToRead !== lastSpokenText || (currentTimeMs - lastSpokenTime) > 1000) {
                    speechSynthesis.cancel();
                    isSpeaking = true;
                    readText(textToRead, () => {
                        isSpeaking = false;
                        if (isRepeating && repeatCount < maxRepeatCount) {
                            repeatCount++;
                            youtubePlayer.seekTo(nextSubtitle.startTime, true);
                        } else {
                            repeatCount = 0;
                        }
                    });
                    lastSpokenText = textToRead;
                    lastSpokenTime = currentTimeMs;
                }
            }
        }

        function updateSubtitleDisplay(index) {
            const startIndex = Math.max(0, index - 2);
            const endIndex = Math.min(subtitleData.length - 1, index + 2);
            let subtitleContent = "";
            const notebookVocab = document.getElementById("notebooklm-vocab").value
                .split("\n")
                .filter(line => line.trim())
                .map(line => line.split(":")[0]?.trim())
                .filter(korean => korean);

            for (let i = startIndex; i <= endIndex; i++) {
                const sub = subtitleData[i];
                const highlightedKoreanText = sub.koreanText.split(/\s+/).map(word => {
                    const cleanWord = word.replace(/[^\p{Script=Hangul}]+/gu, "").trim();
                    const isNotebookVocab = notebookVocab.some(v => v.includes(cleanWord) || cleanWord.includes(v));
                    
                    if (isNotebookVocab) {
                        return `<span class="korean-word learned" onclick="handleWordClick('${cleanWord}')" 
                                style="font-weight:bold;background-color:#e3f2fd;padding:2px 4px;border-radius:3px;border-bottom:2px solid #2196F3;">
                                ${word}</span>`;
                    }
                    return `<span class="korean-word" onclick="handleWordClick('${cleanWord}')">${word}</span>`;
                }).join(" ");
                const isCurrent = i === index ? "current" : "";
                subtitleContent += `<div class="subtitle-line ${isCurrent}"> ${formatTime(sub.startTime)}: ${highlightedKoreanText} <span class="vietnamese">${sub.vietnameseText}</span> </div>`;
            }
            document.getElementById("subtitle-display").innerHTML = subtitleContent;
            
            highlightSubtitle(index);

            // === AUTO SCROLL ACTIVE SUBTITLE ===
            setTimeout(() => {
                const activeItem = document.querySelector('.subtitle-item.active');
                if (activeItem) {
                    activeItem.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }, 50);
        }


        function readText(text, callback) {
            if (!text) {
                callback?.();
                return;
            }
            try {
                if (typeof speechSynthesis === 'undefined' || !speechSynthesis) {
                    console.error("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Speech API");
                    alert("Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ch·ª©c nƒÉng ƒë·ªçc vƒÉn b·∫£n (TTS).");
                    callback?.();
                    return;
                }
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = ttsLanguage;
                utterance.rate = ttsSpeed;
                utterance.volume = ttsVolume;
                const voices = speechSynthesis.getVoices();
                if (!voices || voices.length === 0) {
                    console.error("Kh√¥ng t√¨m th·∫•y gi·ªçng ƒë·ªçc n√†o");
                    alert("Kh√¥ng t√¨m th·∫•y gi·ªçng ƒë·ªçc ph√π h·ª£p. Vui l√≤ng ki·ªÉm tra c√†i ƒë·∫∑t ng√¥n ng·ªØ tr√™n thi·∫øt b·ªã.");
                    callback?.();
                    return;
                }
                const preferredVoice = voices.find(voice => voice.lang === ttsLanguage);
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                } else {
                    console.warn("Kh√¥ng t√¨m th·∫•y gi·ªçng ƒë·ªçc ph√π h·ª£p v·ªõi ng√¥n ng·ªØ", ttsLanguage);
                }
                utterance.onend = () => {
                    callback?.();
                };
                utterance.onerror = (event) => {
                    console.error("L·ªói TTS:", event);
                    callback?.();
                };
                speechSynthesis.speak(utterance);
            } catch (error) {
                console.error("L·ªói khi ƒë·ªçc vƒÉn b·∫£n:", error);
                callback?.();
            }
        }

        function removeBracketsContent(text) {
            return text.replace(/\[[^\]]*\]/g, '').trim();
        }

        function readTextDual(text, callback) {
            const cleanedText = removeBracketsContent(text);
            const parts = cleanedText.split("-");
            const koreanPart = parts[0] ? parts[0].trim() : "";
            const vietnamesePart = parts[1] ? parts[1].trim() : "";

            if (koreanPart) {
                const koUtterance = new SpeechSynthesisUtterance(koreanPart);
                koUtterance.lang = "ko-KR";
                koUtterance.rate = ttsSpeed;
                koUtterance.volume = ttsVolume;

                koUtterance.onend = () => {
                    if (vietnamesePart) {
                        const viUtterance = new SpeechSynthesisUtterance(vietnamesePart);
                        viUtterance.lang = "vi-VN";
                        viUtterance.rate = ttsSpeed;
                        viUtterance.volume = ttsVolume;
                        viUtterance.onend = callback;
                        speechSynthesis.speak(viUtterance);
                    } else if (callback) {
                        callback();
                    }
                };
                speechSynthesis.speak(koUtterance);
            } else if (vietnamesePart) {
                const viUtterance = new SpeechSynthesisUtterance(vietnamesePart);
                viUtterance.lang = "vi-VN";
                viUtterance.rate = ttsSpeed;
                viUtterance.volume = ttsVolume;
                viUtterance.onend = callback;
                speechSynthesis.speak(viUtterance);
            } else if (callback) {
                callback();
            }
        }

        function stopReading() {
            if (typeof speechSynthesis !== "undefined") {
                speechSynthesis.cancel();
                isSpeaking = false;
            }
            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
            }
            isRepeating = false;
            repeatCount = 0;
        }

        function toggleRepeat() {
            isRepeating = !isRepeating;
            alert(isRepeating ? "ƒê√£ b·∫≠t ch·∫ø ƒë·ªô l·∫∑p ph·ª• ƒë·ªÅ (3 l·∫ßn)" : "ƒê√£ t·∫Øt ch·∫ø ƒë·ªô l·∫∑p ph·ª• ƒë·ªÅ");
        }

        function rewindSubtitle() {
            if (!youtubePlayer || subtitleData.length === 0) {
                alert("Vui l√≤ng t·∫£i video v√† ph·ª• ƒë·ªÅ tr∆∞·ªõc!");
                return;
            }
            const currentTime = youtubePlayer.getCurrentTime();
            const rewindTime = Math.max(0, currentTime - 5);
            let newIndex = -1;
            for (let i = subtitleData.length - 1; i >= 0; i--) {
                if (subtitleData[i].startTime <= rewindTime) {
                    newIndex = i;
                    break;
                }
            }
            if (newIndex >= 0) {
                youtubePlayer.seekTo(rewindTime, true);
                currentSubtitleIndex = newIndex - 1;
                updateSubtitleDisplay(newIndex);
                if (youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                    youtubePlayer.playVideo();
                }
            }
        }

        function saveToHistory(videoUrl, srtContent, notebooklmVocab) {
            currentVideoUrl = videoUrl;
            const existingIndex = history.findIndex(item => item.videoUrl === videoUrl);
            const currentVocab = vocabList.slice();
            const currentFavorites = currentVideoFavorites.slice();
            if (existingIndex !== -1) {
                history[existingIndex].srtContent = srtContent || history[existingIndex].srtContent;
                history[existingIndex].vocabList = currentVocab;
                history[existingIndex].notebooklmVocab = notebooklmVocab || history[existingIndex].notebooklmVocab;
                history[existingIndex].favoriteSubtitles = currentFavorites;
            } else {
                history.push({ 
                    videoUrl, 
                    srtContent, 
                    vocabList: currentVocab, 
                    notebooklmVocab: notebooklmVocab,
                    favoriteSubtitles: currentFavorites
                });
            }
            localStorage.setItem("videoHistory", JSON.stringify(history));
            displayHistory();
        }

        function displayHistory() {
            const historyList = document.getElementById("history-list");
            historyList.innerHTML = "";
            history.forEach((item, index) => {
                const div = document.createElement("div");
                div.className = "history-item";
                div.innerHTML = ` ${item.videoUrl} ${item.srtContent ? "(C√≥ ph·ª• ƒë·ªÅ)" : ""} ${item.vocabList && item.vocabList.length > 0 ? `(${item.vocabList.length} t·ª´ v·ª±ng)` : ""} <button onclick="deleteHistoryItem(${index})">X√≥a</button> `;
                div.onclick = (e) => {
                    if (e.target.tagName !== "BUTTON") loadFromHistory(index);
                };
                historyList.appendChild(div);
            });
        }

        async function loadFromHistory(index) {
            const item = history[index];
            if (!item) return;
            document.getElementById("video-url").value = item.videoUrl;
            currentVideoUrl = item.videoUrl;
            
            loadVideo();
            try {
                await Promise.all([waitForPlayer(), waitForVoices()]);
                if (item.srtContent) {
                    subtitleData = parseSRT(item.srtContent);
                    displaySubtitleList();
                } else {
                    subtitleData = [];
                    document.getElementById("subtitle-list").innerHTML = "";
                    document.getElementById("subtitle-display").innerHTML = "";
                }
                
                vocabList = item.vocabList ? item.vocabList.slice() : [];
                document.getElementById("notebooklm-vocab").value = item.notebooklmVocab || "";
                currentVideoFavorites = item.favoriteSubtitles ? item.favoriteSubtitles.slice() : [];
                displayVocabList();
                linkVocabToSubtitles();
                displayFavorites();
                
                instantLookupEnabled = localStorage.getItem("instantLookup") === "1";
                document.getElementById("instant-lookup-toggle").checked = instantLookupEnabled;
                if (ttsVolume === 0) {
                    alert("√Çm l∆∞·ª£ng TTS hi·ªán b·∫±ng 0. Vui l√≤ng ƒëi·ªÅu ch·ªânh thanh tr∆∞·ª£t √¢m l∆∞·ª£ng TTS.");
                }
                if (youtubePlayer && youtubePlayer.playVideo) {
                    youtubePlayer.playVideo();
                    setTimeout(startReading, 1000);
                }
            } catch (error) {
                console.error("L·ªói khi t·∫£i l·ªãch s·ª≠:", error);
                alert("C√≥ l·ªói x·∫£y ra khi t·∫£i l·ªãch s·ª≠: " + error.message);
            }
        }

        function deleteHistoryItem(index) {
            history.splice(index, 1);
            localStorage.setItem("videoHistory", JSON.stringify(history));
            displayHistory();
            displayFavorites();
        }

        function toggleNaverLookup(enabled) {
            naverLookupEnabled = enabled;
            localStorage.setItem("naverLookup", enabled ? "1" : "0");
            displayVocabList();
        }

        function openNaverDict(word) {
            window.open(`https://korean.dict.naver.com/kovidict/#/search?query=${encodeURIComponent(word)}`, "_blank");
        }

        function displayVocabList() {
            const vocabListDiv = document.getElementById("vocab-list");
            vocabListDiv.innerHTML = "";
            vocabList.forEach((item, index) => {
                const div = document.createElement("div");
                div.className = "vocab-item";
                if (naverLookupEnabled) {
                    div.className = "vocab-item-naver";
                    div.innerHTML = `<div> <span class="korean-word clickable" onclick="openNaverDict('${item.word}')">${item.word}</span> <span class="vietnamese translation">${item.meaning}</span> </div> <button onclick="deleteVocab(${index})">X√≥a</button> `;
                } else {
                    div.innerHTML = ` <input type="text" value="${item.word}" onchange="editVocab(${index}, 'word', this.value)"> <input type="text" value="${item.meaning}" placeholder="Nh·∫≠p nghƒ©a..." onchange="editVocab(${index}, 'meaning', this.value)"> <button onclick="deleteVocab(${index})">X√≥a</button> `;
                }
                vocabListDiv.appendChild(div);
            });
        }

        function editVocab(index, field, value) {
            vocabList[index][field] = value;
            saveVocabToHistory();
        }

        function deleteVocab(index) {
            vocabList.splice(index, 1);
            saveVocabToHistory();
            displayVocabList();
        }

        function saveVocabToHistory() {
            const existingIndex = history.findIndex(item => item.videoUrl === currentVideoUrl);
            if (existingIndex !== -1) {
                history[existingIndex].vocabList = vocabList.slice();
                history[existingIndex].notebooklmVocab = document.getElementById("notebooklm-vocab").value;
                history[existingIndex].favoriteSubtitles = currentVideoFavorites.slice();
                localStorage.setItem("videoHistory", JSON.stringify(history));
            }
        }

        function addFavoriteToCurrentVideo(index) {
            const sub = subtitleData[index];
            if (!sub) return;
            const existing = currentVideoFavorites.find(item => item.koreanText === sub.koreanText && item.vietnameseText === sub.vietnameseText);
            if (!existing) {
                currentVideoFavorites.push(sub);
                saveVocabToHistory();
                displayFavorites();
                alert("ƒê√£ th√™m v√†o ph·ª• ƒë·ªÅ y√™u th√≠ch!");
            } else {
                alert("Ph·ª• ƒë·ªÅ n√†y ƒë√£ c√≥ trong danh s√°ch y√™u th√≠ch c·ªßa video n√†y.");
            }
        }

        function removeFavorite(index) {
            currentVideoFavorites.splice(index, 1);
            saveVocabToHistory();
            displayFavorites();
        }
        
        function displayFavorites() {
            const favoriteList = document.getElementById("favorite-subtitles");
            favoriteList.innerHTML = "";
            currentVideoFavorites.forEach((sub, index) => {
                const div = document.createElement("div");
                div.className = "subtitle-item";
                div.innerHTML = `<span class="korean">${sub.koreanText}</span> <span class="vietnamese">${sub.vietnameseText}</span> <button onclick="removeFavorite(${index}); event.stopPropagation();">X√≥a</button>`;
                div.onclick = () => jumpToSubtitleByText(sub.koreanText);
                favoriteList.appendChild(div);
            });
        }
        
        function clearAllFavorites() {
            if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô ph·ª• ƒë·ªÅ y√™u th√≠ch c·ªßa video hi·ªán t·∫°i?")) {
                currentVideoFavorites = [];
                saveVocabToHistory();
                displayFavorites();
            }
        }

        function jumpToSubtitleByText(text) {
            const index = subtitleData.findIndex(sub => sub.koreanText === text);
            if (index !== -1) {
                jumpToSubtitle(index);
            } else {
                alert("Kh√¥ng t√¨m th·∫•y ph·ª• ƒë·ªÅ t∆∞∆°ng ·ª©ng trong video hi·ªán t·∫°i.");
            }
        }

        function saveState() {
            const state = {
                history: history,
                ttsSpeed: ttsSpeed,
                ttsLanguage: ttsLanguage,
                ttsVolume: ttsVolume,
                instantLookupEnabled: instantLookupEnabled,
                naverLookupEnabled: naverLookupEnabled,
                subtitleOffset: subtitleOffset,
                vocabDisplayMode: vocabDisplayMode
            };
            const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `youtube_state_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            alert("ƒê√£ l∆∞u tr·∫°ng th√°i!");
        }

        function loadState() {
            const fileInput = document.getElementById("state-file").files[0];
            if (!fileInput) {
                alert("Vui l√≤ng ch·ªçn file JSON ƒë·ªÉ t·∫£i!");
                return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const state = JSON.parse(event.target.result);
                    history = state.history || [];
                    ttsSpeed = state.ttsSpeed || 1.5;
                    ttsLanguage = state.ttsLanguage || "vi-VN";
                    ttsVolume = state.ttsVolume || 1.0;
                    instantLookupEnabled = state.instantLookupEnabled ?? true;
                    naverLookupEnabled = state.naverLookupEnabled ?? false;
                    subtitleOffset = state.subtitleOffset ?? 0;
                    vocabDisplayMode = state.vocabDisplayMode ?? false;

                    localStorage.setItem("videoHistory", JSON.stringify(history));
                    localStorage.setItem("ttsSpeed", ttsSpeed);
                    localStorage.setItem("ttsLanguage", ttsLanguage);
                    localStorage.setItem("ttsVolume", ttsVolume);
                    localStorage.setItem("instantLookup", instantLookupEnabled ? "1" : "0");
                    localStorage.setItem("naverLookup", naverLookupEnabled ? "1" : "0");
                    localStorage.setItem("subtitleOffset", subtitleOffset);
                    localStorage.setItem("vocabDisplayMode", vocabDisplayMode);

                    document.getElementById("tts-speed").value = ttsSpeed;
                    document.getElementById("speed-value").textContent = ttsSpeed;
                    document.getElementById("tts-language").value = ttsLanguage;
                    document.getElementById("tts-volume").value = ttsVolume;
                    document.getElementById("video-volume").value = ttsVolume * 100;
                    document.getElementById("video-volume-value").textContent = ttsVolume * 100;
                    document.getElementById("instant-lookup-toggle").checked = instantLookupEnabled;
                    document.getElementById("naver-lookup-toggle").checked = naverLookupEnabled;
                    document.getElementById("subtitle-offset").value = subtitleOffset;
                    document.getElementById("offset-value").textContent = subtitleOffset.toFixed(1);
                    document.getElementById("vocab-display-mode").checked = vocabDisplayMode;

                    displayHistory();
                    alert("ƒê√£ t·∫£i tr·∫°ng th√°i th√†nh c√¥ng!");
                } catch (e) {
                    console.error("L·ªói khi ƒë·ªçc file JSON:", e);
                    alert("File kh√¥ng h·ª£p l·ªá!");
                }
            };
            reader.readAsText(fileInput);
        }

        function toggleVocabTTSMode() {
            vocabTTSMode = !vocabTTSMode;
            const button = document.getElementById("vocab-tts-toggle");
            button.textContent = `Ch·∫ø ƒë·ªô ƒë·ªçc t·ª´ v·ª±ng (${vocabTTSMode ? "B·∫≠t" : "T·∫Øt"})`;
            
            const startBtn = document.getElementById("start-vocab-tts");
            const pauseBtn = document.getElementById("pause-vocab-tts");
            const stopBtn = document.getElementById("stop-vocab-tts");
            
            startBtn.disabled = !vocabTTSMode;
            pauseBtn.disabled = !vocabTTSMode;
            stopBtn.disabled = !vocabTTSMode;
            
            if (!vocabTTSMode) {
                stopVocabTTS();
            }
        }

        function startVocabTTS() {
            if (!vocabTTSMode) return;

            const container = document.getElementById("linked-vocab-list");
            const items = Array.from(container.querySelectorAll(".clickable-vocab"));
            if (items.length === 0) {
                alert("Kh√¥ng c√≥ t·ª´ v·ª±ng ƒë·ªÉ ƒë·ªçc! H√£y nh·∫•n 'Li√™n k·∫øt t·ª´ v·ª±ng v·ªõi ph·ª• ƒë·ªÅ' tr∆∞·ªõc.");
                return;
            }

            const vocabItems = items.map(div => {
                const parts = div.textContent.split("-");
                return {
                    korean: parts[0]?.trim() || "",
                    vietnamese: parts.slice(1).join("-").trim() || ""
                };
            }).filter(item => item.korean);

            if (vocabItems.length === 0) {
                alert("Kh√¥ng t√¨m th·∫•y t·ª´ v·ª±ng h·ª£p l·ªá!");
                return;
            }

            isVocabTTSPaused = false;
            vocabTTSIndex = pausedVocabIndex >= 0 ? pausedVocabIndex : 0;
            pausedVocabIndex = -1;
            readVocabItem(vocabItems);
        }

        function readVocabItem(vocabItems) {
            if (vocabTTSIndex >= vocabItems.length || isVocabTTSPaused) return;
            const item = vocabItems[vocabTTSIndex];
            highlightCurrentVocabItem(vocabTTSIndex);

            const textToRead = `${item.korean} - ${item.vietnamese}`;
            readTextDual(textToRead, () => {
                vocabTTSIndex++;
                if (vocabTTSIndex < vocabItems.length && !isVocabTTSPaused) {
                    vocabTTSTimeout = setTimeout(() => readVocabItem(vocabItems), 500);
                }
            });
        }

        function highlightCurrentVocabItem(index) {
            const container = document.getElementById("linked-vocab-list");
            const items = container.querySelectorAll(".clickable-vocab");
            items.forEach((item, i) => {
                item.style.backgroundColor = i === index ? "#d0e8ff" : "";
            });
        }

        function pauseVocabTTS() {
            if (!vocabTTSMode || vocabTTSIndex === -1) return;
            isVocabTTSPaused = !isVocabTTSPaused;
            document.getElementById("pause-vocab-tts").textContent = 
                isVocabTTSPaused ? "Ti·∫øp t·ª•c" : "T·∫°m d·ª´ng";
            if (isVocabTTSPaused) {
                pausedVocabIndex = vocabTTSIndex;
                speechSynthesis.cancel();
                clearTimeout(vocabTTSTimeout);
            } else {
                startVocabTTS();
            }
        }

        function stopVocabTTS() {
            isVocabTTSPaused = false;
            vocabTTSIndex = -1;
            pausedVocabIndex = -1;
            speechSynthesis.cancel();
            clearTimeout(vocabTTSTimeout);
            highlightCurrentVocabItem(-1);
        }

        function testTTS() {
            readText("Ki·ªÉm tra gi·ªçng ƒë·ªçc", () => {});
        }

        function loadInitialState() {
            try {
                history = JSON.parse(localStorage.getItem("videoHistory")) || [];
                ttsSpeed = parseFloat(localStorage.getItem("ttsSpeed")) || 1.5;
                ttsLanguage = localStorage.getItem("ttsLanguage") || "vi-VN";
                ttsVolume = parseFloat(localStorage.getItem("ttsVolume")) || 1.0;
                instantLookupEnabled = localStorage.getItem("instantLookup") !== "0";
                naverLookupEnabled = localStorage.getItem("naverLookup") === "1";
                subtitleOffset = parseFloat(localStorage.getItem("subtitleOffset")) || 0;
                vocabDisplayMode = localStorage.getItem("vocabDisplayMode") === "true";

                document.getElementById("tts-speed").value = ttsSpeed;
                document.getElementById("speed-value").textContent = ttsSpeed;
                document.getElementById("tts-language").value = ttsLanguage;
                document.getElementById("tts-volume").value = ttsVolume;
                document.getElementById("video-volume").value = ttsVolume * 100;
                document.getElementById("video-volume-value").textContent = ttsVolume * 100;
                document.getElementById("instant-lookup-toggle").checked = instantLookupEnabled;
                document.getElementById("naver-lookup-toggle").checked = naverLookupEnabled;
                document.getElementById("subtitle-offset").value = subtitleOffset;
                document.getElementById("offset-value").textContent = subtitleOffset.toFixed(1);
                document.getElementById("vocab-display-mode").checked = vocabDisplayMode;

                displayHistory();
            } catch (e) {
                console.error("L·ªói khi t·∫£i tr·∫°ng th√°i:", e);
            }
        }

        window.onload = loadInitialState;
    </script>
</body>
        </html>
